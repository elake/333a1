map = [[0x7, 0x5, 0x0, 0x4, 0x2, 0x3, 0xb, 0x6, 0xa, 0x8, 0x9, 0xd, 0xc, 0xf, 0xe, 0x1],[0x3, 0x8, 0xd, 0xa, 0xc, 0xe, 0xf, 0xb, 0x7, 0x6, 0x4, 0x5, 0x1, 0x2, 0x0, 0x9],[0x4, 0x0, 0x3, 0x1, 0xb, 0xa, 0x8, 0x5, 0x9, 0xd,0xc, 0xe, 0xf, 0x6, 0x7, 0x2],[0x9, 0xe, 0x7, 0xc, 0x6, 0x4, 0x5, 0xd, 0x1, 0x0, 0x2, 0x3, 0xb, 0x8, 0xa, 0xf],[0x1, 0x3, 0xa, 0x2, 0x8, 0x9, 0xd, 0x0, 0xc, 0xe, 0xf, 0x7, 0x6, 0x5, 0x4, 0xb],[0xe, 0x6, 0x5, 0x7, 0x1, 0x0, 0x2, 0xf, 0x3, 0xb, 0xa, 0x8,0x9, 0xc, 0xd, 0x4],[0x2, 0xa, 0x9, 0xb, 0xd, 0xc, 0xe, 0x3, 0xf, 0x7, 0x6, 0x4, 0x5, 0x0, 0x1, 0x8],[0x6, 0x1, 0x2, 0x5, 0x3, 0xb, 0xa, 0x4, 0x8, 0x9, 0xd, 0xc, 0xe, 0x7, 0xf, 0x0],[0xb, 0x9, 0xc, 0x8, 0xe, 0xf, 0x7, 0xa, 0x6, 0x4, 0x5, 0x1, 0x0, 0x3,0x2, 0xd],[0x0, 0xb, 0x8, 0x3, 0x9, 0xd, 0xc, 0x2, 0xe, 0xf, 0x7, 0x6, 0x4, 0x1, 0x5, 0xa],[0x8, 0xc, 0xf, 0xd, 0x7, 0x6, 0x4, 0x9, 0x5, 0x1, 0x0, 0x2, 0x3, 0xa, 0xb, 0xe],[0x5, 0x2, 0xb, 0x0, 0xa, 0x8, 0x9, 0x1, 0xd, 0xc, 0xe, 0xf, 0x7, 0x4, 0x6, 0x3],[0xd, 0xf, 0x6, 0xe, 0x4, 0x5, 0x1, 0xc, 0x0, 0x2, 0x3, 0xb, 0xa, 0x9, 0x8, 0x7],[0xc, 0x7, 0x4, 0xf, 0x5, 0x1, 0x0, 0xe, 0x2, 0x3, 0xb, 0xa, 0x8, 0xd, 0x9, 0x6],[0xa, 0xd, 0xe, 0x9, 0xf, 0x7, 0x6, 0x8, 0x4, 0x5, 0x1, 0x0, 0x2, 0xb, 0x3, 0xc],[0xf, 0x4, 0x1, 0x6, 0x0, 0x2, 0x3, 0x7, 0xb, 0xa, 0x8, 0x9, 0xd, 0xe, 0xc, 0x5]]

def check(c, k, map):
    """
    Decrypts a single hex digit (4 bits).
    
    >>> check(7, 10, map)
    3
    >>> check(0x7, 0xa, map)
    3
    """
    for i in range(len(map)):
        if map[0][i] == k:
            x = i

    for i in range(len(map)):
        if map[i][x] == c:
            return map[i][0]

def lobcheck(c, k, map):
    """
    Takes two lists of integer bytes (use ord to convert bytes to integers)
    and decrypts c using key k. Returns a list of integers base 10.

    >>>lobcheck([0xa2, 0xbb, 0x2a], [0x43, 0x42, 0x41], map)
    [67, 66, 65]
    """
    rval = []
    ii = 0
    while ii < len(c):
        for i in range(len(k)):
            cur = c[ii]
            ii += 1
            xlow = check(cur % 16, k[i] >> 4, map)
            xhigh = check(cur >> 4, k[i] % 16, map)
            rval.insert(0, (xhigh << 4) + xlow)
    return rval

def brute(c, kl, map):
    """
    Takes a list of keys (keys are also lists) and tries all of the keys.
    Only returns if every character is printable ascii.
    
    >>> brute([162, 187, 42], [[67, 66, 65], [55, 43, 44]], map)
    [67, 66, 65]
    """

    for k in kl:
        if max(lobcheck(c, k, map)) <= 127:
            return k

def key_generator(n, charset, curl=None):
    """
    Currently incomplete, takes a maximum keylength n and a set of
    allowable characters, and returns every possible key within
    those boundaries. 
    """
    if not curl:
        curl = [[x] for x in charset]
    elif len(curl[len(curl)-1]) >= n:
        return curl
    else:
        pass
        
def v_freq(ct, kl):
    """
    Takes a ciphertext and provides a frequency table for each
    character of the key given the proposed keylength.

    >>> v_freq(['a', 'b', 'c', 'b', 'c', 'c'], 2)
    {0: Counter({'c': 2, 'a': 1}), 1: Counter({'b': 2})}
    """
    frequency_map = {}
    from collections import Counter
    for i in range(kl):
        curlist = [ct[i] for i in range(i, len(ct)-1, kl)]
        frequency_map[i] = Counter(curlist)
    return frequency_map
        
#xord is the ciphertext as a list of integers
xord = []
f = open("ciphertext1", "rb")
while True:
    fc = f.read(1)
    if fc:
        xord.append(ord(fc))
    else:
        break
