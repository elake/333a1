map = [[0x7, 0x5, 0x0, 0x4, 0x2, 0x3, 0xb, 0x6, 0xa, 0x8, 0x9, 0xd, 0xc, 0xf, 0xe, 0x1],
       [0x3, 0x8, 0xd, 0xa, 0xc, 0xe, 0xf, 0xb, 0x7, 0x6, 0x4, 0x5, 0x1, 0x2, 0x0, 0x9],
       [0x4, 0x0, 0x3, 0x1, 0xb, 0xa, 0x8, 0x5, 0x9, 0xd, 0xc, 0xe, 0xf, 0x6, 0x7, 0x2],
       [0x9, 0xe, 0x7, 0xc, 0x6, 0x4, 0x5, 0xd, 0x1, 0x0, 0x2, 0x3, 0xb, 0x8, 0xa, 0xf],
       [0x1, 0x3, 0xa, 0x2, 0x8, 0x9, 0xd, 0x0, 0xc, 0xe, 0xf, 0x7, 0x6, 0x5, 0x4, 0xb],
       [0xe, 0x6, 0x5, 0x7, 0x1, 0x0, 0x2, 0xf, 0x3, 0xb, 0xa, 0x8, 0x9, 0xc, 0xd, 0x4],
       [0x2, 0xa, 0x9, 0xb, 0xd, 0xc, 0xe, 0x3, 0xf, 0x7, 0x6, 0x4, 0x5, 0x0, 0x1, 0x8],
       [0x6, 0x1, 0x2, 0x5, 0x3, 0xb, 0xa, 0x4, 0x8, 0x9, 0xd, 0xc, 0xe, 0x7, 0xf, 0x0],
       [0xb, 0x9, 0xc, 0x8, 0xe, 0xf, 0x7, 0xa, 0x6, 0x4, 0x5, 0x1, 0x0, 0x3, 0x2, 0xd],
       [0x0, 0xb, 0x8, 0x3, 0x9, 0xd, 0xc, 0x2, 0xe, 0xf, 0x7, 0x6, 0x4, 0x1, 0x5, 0xa],
       [0x8, 0xc, 0xf, 0xd, 0x7, 0x6, 0x4, 0x9, 0x5, 0x1, 0x0, 0x2, 0x3, 0xa, 0xb, 0xe],
       [0x5, 0x2, 0xb, 0x0, 0xa, 0x8, 0x9, 0x1, 0xd, 0xc, 0xe, 0xf, 0x7, 0x4, 0x6, 0x3],
       [0xd, 0xf, 0x6, 0xe, 0x4, 0x5, 0x1, 0xc, 0x0, 0x2, 0x3, 0xb, 0xa, 0x9, 0x8, 0x7],
       [0xc, 0x7, 0x4, 0xf, 0x5, 0x1, 0x0, 0xe, 0x2, 0x3, 0xb, 0xa, 0x8, 0xd, 0x9, 0x6],
       [0xa, 0xd, 0xe, 0x9, 0xf, 0x7, 0x6, 0x8, 0x4, 0x5, 0x1, 0x0, 0x2, 0xb, 0x3, 0xc],
       [0xf, 0x4, 0x1, 0x6, 0x0, 0x2, 0x3, 0x7, 0xb, 0xa, 0x8, 0x9, 0xd, 0xe, 0xc, 0x5]]

def check(c, k, map, e=None):
    """
    Decrypts a single hex digit, encrypts if e.
    """
    if e:
        return map[c][k]
    for i in range(len(map)):
        if map[i][k] == c:
            return i

def lobcheck(c, k, map, e=None):
    """
    Takes two lists of integer bytes (use ord to convert bytes to integers)
    and decrypts c using key k. Returns a list of integers base 10. Encrypts
    if e.

    >>>lobcheck([0xa2, 0xbb, 0x2a], [0x43, 0x42, 0x41], map)
    [67, 66, 65]
    """
    rval = []
    ii = 0
    while ii < len(c):
        for i in range(len(k)):
            try:
                cur = c[ii]
            except IndexError:
                break
            ii += 1
            xlow = check(cur % 16, k[i] >> 4, map, e)
            xhigh = check(cur >> 4, k[i] % 16, map, e)
            rval.append((xhigh << 4) + xlow)
    return rval
      
def v_freq(ct, kl):
    """
    Takes a ciphertext and provides a frequency table for each
    character of the key given the proposed keylength.

    >>> v_freq(['a', 'b', 'c', 'b', 'c', 'c'], 2)
    {0: Counter({'c': 2, 'a': 1}), 1: Counter({'b': 2})}
    """
    frequency_map = {}
    from collections import Counter
    for i in range(kl):
        curlist = [ct[i] for i in range(i, len(ct)-1, kl)]
        frequency_map[i] = Counter(curlist)
    return frequency_map
        
#xord is the ciphertext as a list of integers
xord = []
f = open("ciphertext2", "rb")
while True:
    fc = f.read(1)
    if fc:
        xord.append(ord(fc))
    else:
        break

def f_check(pset, kset, cbyte, map):
    """
    returns tuples of possible plaintext and key bytes
    that form c with the given map.
    """
    combos = []
    for p in pset:
        for k in kset:
            if lobcheck([p], [k], map, 1) == [cbyte]:
                combos.append((p, k))
    return combos

def rev_byte(cb, pb, map):
    """
    Takes a known ciphertext byte and a guess plaintext byte,
    and returns the key byte that would encrypt pb to cb.
    """
    # Split the hex bytes into their single digit components
    ch , ph = cb >> 4, pb >> 4
    cl , pl = cb %  16, pb % 16
    # Determine the high key value
    for i in range(len(map)):
        if map[ph][i] == ch:
            kl = i
    # Determine the low key value
    for i in range(len(map)):
        if map[pl][i] == cl:
            kh = i
    # Combine the low and high key values
    return (kh << 4) + kl

def keyFromCommonCharacters(ct, kl, guess, map):
    """
    This function assumes that there is a most common character,
    guess. It then returns a key that would result in the most
    common cyphertext byte for each keyspace to decrypt to guess.
    """

    keyspace = v_freq(ct, kl)
    commons = []
    for i in range(len(keyspace)):
        commons.append(max(keyspace[i], key=keyspace[i].get))
    key = []
    for c in commons:
        key.append(rev_byte(c, guess, map))
    return key

def show(text, l=None):
    """
    Takes a list of ints and prints them as an ASCII string.
    If l is given, only prints l characters.
    """
    rval = 'Result: '
    for x in text[0:l]:
        rval = rval + chr(x)
    print(rval)

def headerCheck(ct, kl, tryfile, map):
    """
    Uses the first kl bytes of tryfile as a guessed known plaintext
    and returns the generated key.
    """
    f = open(tryfile, "rb")
    known = []
    for i in range(kl):
        known.append(ord(f.read(1)))
    key = []
    for i in range(kl):
        key.append(rev_byte(ct[i], known[i], map))
    return key
